/**
 * Form Conversion PDF Export Service
 *
 * Generates filled PDF forms by overlaying form data onto original PDF templates.
 * Supports both native PDFs and image-based exports.
 */

import pdfMake from 'pdfmake/build/pdfmake'
import type { TDocumentDefinitions, Content } from 'pdfmake/interfaces'
import { prisma } from '@/lib/db'

// Define fonts for pdfmake
const fonts = {
  Roboto: {
    normal: 'Helvetica',
    bold: 'Helvetica-Bold',
    italics: 'Helvetica-Oblique',
    bolditalics: 'Helvetica-BoldOblique',
  },
}

export interface FieldPosition {
  fieldSlug: string
  x: number
  y: number
  width: number
  height: number
  page: number
  fontSize?: number
  fontColor?: string
  alignment?: 'left' | 'center' | 'right'
}

export interface FilledFormData {
  [fieldSlug: string]: string | boolean | string[] | undefined
}

export interface ExportOptions {
  includeEmptyFields?: boolean
  dateFormat?: string
  fontSize?: number
  fontColor?: string
}

/**
 * Export a filled form as a new PDF (standalone, not overlay)
 */
export async function exportFilledForm(
  formId: string,
  submissionId: string,
  options: ExportOptions = {}
): Promise<Buffer> {
  // Get form with fields
  const form = await prisma.form.findUnique({
    where: { id: formId },
    include: {
      fields: {
        orderBy: { order: 'asc' },
      },
    },
  })

  if (!form) {
    throw new Error('Form not found')
  }

  // Get submission data
  const submission = await prisma.formSubmission.findUnique({
    where: { id: submissionId },
    include: {
      client: {
        select: {
          firstName: true,
          lastName: true,
        },
      },
    },
  })

  if (!submission) {
    throw new Error('Submission not found')
  }

  const data = (submission.data as FilledFormData) || {}

  // Group fields by section
  const fieldsBySection = groupFieldsBySection(form.fields)

  // Build PDF content
  const content: Content[] = []

  // Title
  content.push({
    text: form.name,
    style: 'header',
    margin: [0, 0, 0, 20],
  })

  // Subtitle with client info
  if (submission.client) {
    content.push({
      text: `Client: ${submission.client.firstName} ${submission.client.lastName}`,
      style: 'subheader',
      margin: [0, 0, 0, 10],
    })
  }

  content.push({
    text: `Submitted: ${submission.submittedAt?.toLocaleDateString() || new Date().toLocaleDateString()}`,
    style: 'date',
    margin: [0, 0, 0, 20],
  })

  // Add sections and fields
  for (const [section, fields] of Object.entries(fieldsBySection)) {
    if (section !== '_default') {
      content.push({
        text: section,
        style: 'sectionHeader',
        margin: [0, 20, 0, 10],
      })
    }

    for (const field of fields) {
      const value = data[field.slug]
      const displayValue = formatFieldValue(value, field.type, options)

      // Skip empty fields if option set
      if (!options.includeEmptyFields && !displayValue) {
        continue
      }

      content.push({
        columns: [
          {
            width: '40%',
            text: field.name + (field.isRequired ? ' *' : ''),
            style: 'fieldLabel',
          },
          {
            width: '60%',
            text: displayValue || 'â€”',
            style: 'fieldValue',
          },
        ],
        margin: [0, 5, 0, 5],
      })
    }
  }

  // Footer
  content.push({
    text: `Generated by Scrybe on ${new Date().toLocaleDateString()}`,
    style: 'footer',
    margin: [0, 40, 0, 0],
  })

  // Build document definition
  const docDefinition: TDocumentDefinitions = {
    content,
    styles: {
      header: {
        fontSize: 18,
        bold: true,
        color: '#1a1a1a',
      },
      subheader: {
        fontSize: 12,
        color: '#4a4a4a',
      },
      date: {
        fontSize: 10,
        color: '#6a6a6a',
        italics: true,
      },
      sectionHeader: {
        fontSize: 14,
        bold: true,
        color: '#2a2a2a',
        decoration: 'underline',
      },
      fieldLabel: {
        fontSize: options.fontSize || 10,
        bold: true,
        color: '#3a3a3a',
      },
      fieldValue: {
        fontSize: options.fontSize || 10,
        color: options.fontColor || '#1a1a1a',
      },
      footer: {
        fontSize: 8,
        color: '#8a8a8a',
        italics: true,
        alignment: 'center',
      },
    },
    defaultStyle: {
      font: 'Roboto',
    },
    pageMargins: [40, 40, 40, 40],
  }

  // Generate PDF
  return new Promise((resolve, reject) => {
    try {
      const pdfDoc = pdfMake.createPdf(docDefinition, undefined, fonts)
      pdfDoc.getBuffer((buffer: Buffer) => {
        resolve(buffer)
      })
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Export form as PDF with overlay on original document
 * This is for forms that were converted from PDFs and need to maintain original formatting
 */
export async function exportWithOverlay(
  conversionId: string,
  submissionId: string,
  options: ExportOptions = {}
): Promise<Buffer> {
  // Get conversion with field positions
  const conversion = await prisma.formConversion.findUnique({
    where: { id: conversionId },
    include: {
      resultForm: {
        include: {
          fields: true,
        },
      },
    },
  })

  if (!conversion || !conversion.resultForm) {
    throw new Error('Conversion or form not found')
  }

  if (!conversion.fieldPositions) {
    // No position data, fall back to standard export
    return exportFilledForm(conversion.resultForm.id, submissionId, options)
  }

  // Get submission data
  const submission = await prisma.formSubmission.findUnique({
    where: { id: submissionId },
  })

  if (!submission) {
    throw new Error('Submission not found')
  }

  const data = (submission.data as FilledFormData) || {}
  const fieldPositions = (conversion.fieldPositions as unknown) as FieldPosition[]

  // Build PDF with positioned text
  const content: Content[] = []

  // For each field position, add positioned text
  for (const position of fieldPositions) {
    const value = data[position.fieldSlug]
    const displayValue = formatFieldValue(
      value,
      conversion.resultForm.fields.find((f) => f.slug === position.fieldSlug)?.type || 'TEXT_SHORT',
      options
    )

    if (!displayValue && !options.includeEmptyFields) {
      continue
    }

    content.push({
      absolutePosition: { x: position.x, y: position.y },
      text: displayValue || '',
      fontSize: position.fontSize || options.fontSize || 10,
      color: position.fontColor || options.fontColor || '#000000',
    } as unknown as Content)
  }

  const docDefinition: TDocumentDefinitions = {
    content,
    defaultStyle: {
      font: 'Roboto',
    },
    pageMargins: [0, 0, 0, 0],
  }

  return new Promise((resolve, reject) => {
    try {
      const pdfDoc = pdfMake.createPdf(docDefinition, undefined, fonts)
      pdfDoc.getBuffer((buffer: Buffer) => {
        resolve(buffer)
      })
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Generate a blank form template PDF
 */
export async function generateBlankFormPdf(formId: string): Promise<Buffer> {
  const form = await prisma.form.findUnique({
    where: { id: formId },
    include: {
      fields: {
        orderBy: { order: 'asc' },
      },
    },
  })

  if (!form) {
    throw new Error('Form not found')
  }

  const fieldsBySection = groupFieldsBySection(form.fields)

  const content: Content[] = []

  // Title
  content.push({
    text: form.name,
    style: 'header',
    margin: [0, 0, 0, 10],
  })

  if (form.description) {
    content.push({
      text: form.description,
      style: 'description',
      margin: [0, 0, 0, 20],
    })
  }

  // Add sections and fields
  for (const [section, fields] of Object.entries(fieldsBySection)) {
    if (section !== '_default') {
      content.push({
        text: section,
        style: 'sectionHeader',
        margin: [0, 20, 0, 10],
      })
    }

    for (const field of fields) {
      // Field label
      content.push({
        text: field.name + (field.isRequired ? ' *' : ''),
        style: 'fieldLabel',
        margin: [0, 10, 0, 2],
      })

      // Help text
      if (field.helpText) {
        content.push({
          text: field.helpText,
          style: 'helpText',
          margin: [0, 0, 0, 2],
        })
      }

      // Input area
      content.push(generateFieldInput(field))
    }
  }

  content.push({
    text: '* Required fields',
    style: 'footer',
    margin: [0, 30, 0, 0],
  })

  const docDefinition: TDocumentDefinitions = {
    content,
    styles: {
      header: {
        fontSize: 18,
        bold: true,
      },
      description: {
        fontSize: 10,
        color: '#666666',
      },
      sectionHeader: {
        fontSize: 14,
        bold: true,
        decoration: 'underline',
      },
      fieldLabel: {
        fontSize: 10,
        bold: true,
      },
      helpText: {
        fontSize: 8,
        color: '#888888',
        italics: true,
      },
      footer: {
        fontSize: 8,
        color: '#888888',
      },
    },
    defaultStyle: {
      font: 'Roboto',
      fontSize: 10,
    },
    pageMargins: [40, 40, 40, 40],
  }

  return new Promise((resolve, reject) => {
    try {
      const pdfDoc = pdfMake.createPdf(docDefinition, undefined, fonts)
      pdfDoc.getBuffer((buffer: Buffer) => {
        resolve(buffer)
      })
    } catch (error) {
      reject(error)
    }
  })
}

// Helper functions

interface FormField {
  slug: string
  name: string
  type: string
  isRequired: boolean
  helpText?: string | null
  section?: string | null
  options?: unknown
}

function groupFieldsBySection(
  fields: FormField[]
): Record<string, FormField[]> {
  const groups: Record<string, FormField[]> = {}

  for (const field of fields) {
    const section = field.section || '_default'
    if (!groups[section]) {
      groups[section] = []
    }
    groups[section].push(field)
  }

  return groups
}

function formatFieldValue(
  value: string | boolean | string[] | undefined,
  fieldType: string,
  options: ExportOptions
): string {
  if (value === undefined || value === null) {
    return ''
  }

  if (typeof value === 'boolean') {
    return value ? 'Yes' : 'No'
  }

  if (Array.isArray(value)) {
    return value.join(', ')
  }

  // Format dates
  if (fieldType === 'DATE' && value) {
    try {
      const date = new Date(value)
      if (!isNaN(date.getTime())) {
        return date.toLocaleDateString(
          undefined,
          options.dateFormat ? { dateStyle: 'long' } : undefined
        )
      }
    } catch {
      // Return as-is if date parsing fails
    }
  }

  return String(value)
}

function generateFieldInput(field: FormField): Content {
  switch (field.type) {
    case 'TEXT_LONG':
      return {
        canvas: [
          {
            type: 'rect',
            x: 0,
            y: 0,
            w: 515,
            h: 60,
            lineWidth: 1,
            lineColor: '#cccccc',
          },
        ],
        margin: [0, 0, 0, 5],
      }

    case 'CHECKBOX':
      const options = (field.options as string[]) || []
      return {
        ul: options.map((opt) => ({
          text: `[ ] ${opt}`,
          margin: [0, 2, 0, 2],
        })),
        margin: [0, 0, 0, 5],
      }

    case 'YES_NO':
      return {
        text: '[ ] Yes   [ ] No',
        margin: [0, 0, 0, 5],
      }

    case 'SIGNATURE':
      return {
        stack: [
          {
            canvas: [
              {
                type: 'line',
                x1: 0,
                y1: 30,
                x2: 200,
                y2: 30,
                lineWidth: 1,
                lineColor: '#000000',
              },
            ],
          },
          {
            text: 'Signature',
            fontSize: 8,
            color: '#888888',
          },
        ],
        margin: [0, 10, 0, 5],
      }

    default:
      // Default text input line
      return {
        canvas: [
          {
            type: 'line',
            x1: 0,
            y1: 15,
            x2: 515,
            y2: 15,
            lineWidth: 1,
            lineColor: '#cccccc',
          },
        ],
        margin: [0, 0, 0, 5],
      }
  }
}
