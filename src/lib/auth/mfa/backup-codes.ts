/**
 * Backup Codes Service for MFA
 *
 * Generates and manages one-time backup codes for account recovery
 * when the authenticator app is unavailable.
 *
 * Security considerations:
 * - Codes are hashed using bcrypt before storage
 * - Each code can only be used once
 * - 10 codes generated by default (HIPAA compliance)
 * - Codes are 8 characters for easy entry
 */

import * as bcrypt from "bcrypt";
import * as crypto from "crypto";

// Configuration
const BACKUP_CODE_COUNT = 10;
const BACKUP_CODE_LENGTH = 8; // 8 alphanumeric characters
const BCRYPT_ROUNDS = 12;

// Character set for backup codes (alphanumeric, avoiding ambiguous chars)
const BACKUP_CODE_CHARSET = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ"; // No 0, 1, I, O

/**
 * Generate a single backup code
 */
function generateSingleCode(): string {
  const bytes = crypto.randomBytes(BACKUP_CODE_LENGTH);
  let code = "";

  for (let i = 0; i < BACKUP_CODE_LENGTH; i++) {
    const index = bytes[i] % BACKUP_CODE_CHARSET.length;
    code += BACKUP_CODE_CHARSET[index];
  }

  return code;
}

/**
 * Format a backup code for display (with dash in middle)
 */
export function formatBackupCode(code: string): string {
  const half = Math.floor(code.length / 2);
  return `${code.slice(0, half)}-${code.slice(half)}`;
}

/**
 * Normalize a backup code (remove dashes, spaces, uppercase)
 */
export function normalizeBackupCode(code: string): string {
  return code.replace(/[-\s]/g, "").toUpperCase().trim();
}

/**
 * Hash a backup code for secure storage
 */
export async function hashBackupCode(code: string): Promise<string> {
  const normalizedCode = normalizeBackupCode(code);
  return bcrypt.hash(normalizedCode, BCRYPT_ROUNDS);
}

/**
 * Verify a backup code against a hash
 */
export async function verifyBackupCode(
  code: string,
  hash: string
): Promise<boolean> {
  const normalizedCode = normalizeBackupCode(code);
  return bcrypt.compare(normalizedCode, hash);
}

export interface BackupCodesResult {
  plainTextCodes: string[]; // Display to user (only shown once)
  hashedCodes: string[]; // Store in database
}

/**
 * Generate a new set of backup codes
 * Returns both plain text (for display) and hashed (for storage)
 */
export async function generateBackupCodes(): Promise<BackupCodesResult> {
  const plainTextCodes: string[] = [];
  const hashedCodes: string[] = [];

  for (let i = 0; i < BACKUP_CODE_COUNT; i++) {
    const code = generateSingleCode();
    plainTextCodes.push(code);

    const hash = await hashBackupCode(code);
    hashedCodes.push(hash);
  }

  return {
    plainTextCodes,
    hashedCodes,
  };
}

/**
 * Format backup codes for display in UI
 */
export function formatCodesForDisplay(codes: string[]): string[] {
  return codes.map(formatBackupCode);
}

/**
 * Find and use a backup code
 * Returns the index of the used code, or -1 if not found
 */
export async function consumeBackupCode(
  inputCode: string,
  storedHashes: string[]
): Promise<number> {
  const normalizedCode = normalizeBackupCode(inputCode);

  // Check against each stored hash
  for (let i = 0; i < storedHashes.length; i++) {
    const hash = storedHashes[i];

    // Skip empty hashes (already used codes are replaced with empty strings)
    if (!hash) continue;

    const isValid = await bcrypt.compare(normalizedCode, hash);
    if (isValid) {
      return i;
    }
  }

  return -1;
}

/**
 * Mark a backup code as used by setting its position to empty
 * Returns the updated array of hashes
 */
export function markCodeAsUsed(
  hashedCodes: string[],
  usedIndex: number
): string[] {
  const updatedCodes = [...hashedCodes];
  updatedCodes[usedIndex] = ""; // Mark as used
  return updatedCodes;
}

/**
 * Count remaining unused backup codes
 */
export function countRemainingCodes(hashedCodes: string[]): number {
  return hashedCodes.filter((code) => code && code.length > 0).length;
}

/**
 * Check if backup codes need to be regenerated
 * (when less than 3 codes remain)
 */
export function shouldRegenerateCodes(hashedCodes: string[]): boolean {
  return countRemainingCodes(hashedCodes) < 3;
}
