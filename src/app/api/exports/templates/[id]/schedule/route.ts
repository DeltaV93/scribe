/**
 * Export Template Schedule API
 *
 * GET /api/exports/templates/[id]/schedule - Get schedule status
 * PUT /api/exports/templates/[id]/schedule - Update schedule
 * POST /api/exports/templates/[id]/schedule - Trigger immediate scheduled run
 */

import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { prisma } from "@/lib/db";
import {
  updateTemplateSchedule,
  executeScheduledExport,
  describeCron,
  getNextRunTime,
  SCHEDULE_PRESETS,
} from "@/lib/services/exports/scheduling";

interface RouteParams {
  params: Promise<{ id: string }>;
}

/**
 * GET - Get schedule status for a template
 */
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const dbUser = await prisma.user.findUnique({
      where: { supabaseUserId: user.id },
      select: { id: true, orgId: true },
    });

    if (!dbUser) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const template = await prisma.exportTemplate.findFirst({
      where: { id, orgId: dbUser.orgId },
      select: {
        id: true,
        name: true,
        scheduleEnabled: true,
        scheduleCron: true,
        scheduleTimezone: true,
        lastScheduledRunAt: true,
        nextScheduledRunAt: true,
        scheduleFailureCount: true,
        status: true,
        exports: {
          where: {
            // Exports that were triggered by schedule (generated by template creator)
          },
          orderBy: { createdAt: "desc" },
          take: 5,
          select: {
            id: true,
            status: true,
            recordCount: true,
            createdAt: true,
            generatedAt: true,
          },
        },
      },
    });

    if (!template) {
      return NextResponse.json({ error: "Template not found" }, { status: 404 });
    }

    // Add human-readable schedule description
    const scheduleDescription = template.scheduleCron
      ? describeCron(template.scheduleCron)
      : null;

    return NextResponse.json({
      templateId: template.id,
      templateName: template.name,
      templateStatus: template.status,
      schedule: {
        enabled: template.scheduleEnabled,
        cronExpression: template.scheduleCron,
        description: scheduleDescription,
        timezone: template.scheduleTimezone,
        lastRunAt: template.lastScheduledRunAt,
        nextRunAt: template.nextScheduledRunAt,
        failureCount: template.scheduleFailureCount,
      },
      recentExports: template.exports,
      presets: SCHEDULE_PRESETS,
    });
  } catch (error) {
    console.error("Error getting schedule:", error);
    return NextResponse.json(
      { error: "Failed to get schedule" },
      { status: 500 }
    );
  }
}

/**
 * PUT - Update schedule for a template
 */
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const dbUser = await prisma.user.findUnique({
      where: { supabaseUserId: user.id },
      select: { id: true, orgId: true, role: true },
    });

    if (!dbUser) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Only admins and program managers can update schedules
    if (!["ADMIN", "SUPER_ADMIN", "PROGRAM_MANAGER"].includes(dbUser.role)) {
      return NextResponse.json({ error: "Insufficient permissions" }, { status: 403 });
    }

    const body = await request.json();
    const { enabled, cronExpression, preset, timezone } = body;

    // Resolve cron expression from preset if provided
    let resolvedCron = cronExpression;
    if (preset && SCHEDULE_PRESETS[preset as keyof typeof SCHEDULE_PRESETS]) {
      resolvedCron = SCHEDULE_PRESETS[preset as keyof typeof SCHEDULE_PRESETS];
    }

    const result = await updateTemplateSchedule(id, dbUser.orgId, {
      enabled: enabled ?? false,
      cronExpression: resolvedCron,
      timezone,
    });

    if (!result.success) {
      return NextResponse.json({ error: result.error }, { status: 400 });
    }

    // Return updated schedule info
    const description = resolvedCron ? describeCron(resolvedCron) : null;

    return NextResponse.json({
      success: true,
      schedule: {
        enabled,
        cronExpression: resolvedCron,
        description,
        timezone: timezone || "America/Los_Angeles",
        nextRunAt: result.nextRunAt,
      },
    });
  } catch (error) {
    console.error("Error updating schedule:", error);
    const message = error instanceof Error ? error.message : "Failed to update schedule";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/**
 * POST - Trigger an immediate scheduled export run
 */
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const dbUser = await prisma.user.findUnique({
      where: { supabaseUserId: user.id },
      select: { id: true, orgId: true, role: true },
    });

    if (!dbUser) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Only admins and program managers can trigger exports
    if (!["ADMIN", "SUPER_ADMIN", "PROGRAM_MANAGER"].includes(dbUser.role)) {
      return NextResponse.json({ error: "Insufficient permissions" }, { status: 403 });
    }

    // Verify template belongs to user's org
    const template = await prisma.exportTemplate.findFirst({
      where: { id, orgId: dbUser.orgId },
    });

    if (!template) {
      return NextResponse.json({ error: "Template not found" }, { status: 404 });
    }

    if (template.status !== "ACTIVE") {
      return NextResponse.json(
        { error: "Only active templates can be exported" },
        { status: 400 }
      );
    }

    // Execute the scheduled export
    const result = await executeScheduledExport(id);

    if (!result.success) {
      return NextResponse.json({ error: result.error }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      exportId: result.exportId,
      message: "Export triggered successfully",
    });
  } catch (error) {
    console.error("Error triggering export:", error);
    const message = error instanceof Error ? error.message : "Failed to trigger export";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
